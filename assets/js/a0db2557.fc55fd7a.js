"use strict";(self.webpackChunkaprendiendo_js=self.webpackChunkaprendiendo_js||[]).push([[7506],{3905:(e,o,n)=>{n.d(o,{Zo:()=>d,kt:()=>b});var r=n(7294);function a(e,o,n){return o in e?Object.defineProperty(e,o,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[o]=n,e}function t(e,o){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);o&&(r=r.filter((function(o){return Object.getOwnPropertyDescriptor(e,o).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var o=1;o<arguments.length;o++){var n=null!=arguments[o]?arguments[o]:{};o%2?t(Object(n),!0).forEach((function(o){a(e,o,n[o])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):t(Object(n)).forEach((function(o){Object.defineProperty(e,o,Object.getOwnPropertyDescriptor(n,o))}))}return e}function l(e,o){if(null==e)return{};var n,r,a=function(e,o){if(null==e)return{};var n,r,a={},t=Object.keys(e);for(r=0;r<t.length;r++)n=t[r],o.indexOf(n)>=0||(a[n]=e[n]);return a}(e,o);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);for(r=0;r<t.length;r++)n=t[r],o.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var i=r.createContext({}),p=function(e){var o=r.useContext(i),n=o;return e&&(n="function"==typeof e?e(o):s(s({},o),e)),n},d=function(e){var o=p(e.components);return r.createElement(i.Provider,{value:o},e.children)},m="mdxType",c={inlineCode:"code",wrapper:function(e){var o=e.children;return r.createElement(r.Fragment,{},o)}},u=r.forwardRef((function(e,o){var n=e.components,a=e.mdxType,t=e.originalType,i=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=p(n),u=a,b=m["".concat(i,".").concat(u)]||m[u]||c[u]||t;return n?r.createElement(b,s(s({ref:o},d),{},{components:n})):r.createElement(b,s({ref:o},d))}));function b(e,o){var n=arguments,a=o&&o.mdxType;if("string"==typeof e||a){var t=n.length,s=new Array(t);s[0]=u;var l={};for(var i in o)hasOwnProperty.call(o,i)&&(l[i]=o[i]);l.originalType=e,l[m]="string"==typeof e?e:a,s[1]=l;for(var p=2;p<t;p++)s[p]=n[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4229:(e,o,n)=>{n.r(o),n.d(o,{assets:()=>i,contentTitle:()=>s,default:()=>c,frontMatter:()=>t,metadata:()=>l,toc:()=>p});var r=n(7462),a=(n(7294),n(3905));const t={title:"Operadores Rest y Spread",slug:"/rest-spread",sidebar_position:4},s="Operadores Rest y Spread",l={unversionedId:"modulo02/dots-operator",id:"modulo02/dots-operator",title:"Operadores Rest y Spread",description:"Estos operadores nos permiten trabajar con arrays y objetos de una manera m\xe1s sencilla. Ambos hacen uso de la sintaxis de puntos ..., sin embargo tienen un significado diferente.",source:"@site/docs/modulo02/dots-operator.md",sourceDirName:"modulo02",slug:"/rest-spread",permalink:"/backend-nodejs-mongodb/rest-spread",draft:!1,editUrl:"https://github.com/ashel1806/backend-nodejs-mongodb/tree/main/docs/modulo02/dots-operator.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Operadores Rest y Spread",slug:"/rest-spread",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Arrays",permalink:"/backend-nodejs-mongodb/arrays"},next:{title:"Callbacks y Promesas",permalink:"/backend-nodejs-mongodb/promises"}},i={},p=[{value:"Operador Rest",id:"operador-rest",level:2},{value:"Operador Spread",id:"operador-spread",level:2}],d={toc:p},m="wrapper";function c(e){let{components:o,...n}=e;return(0,a.kt)(m,(0,r.Z)({},d,n,{components:o,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"operadores-rest-y-spread"},"Operadores Rest y Spread"),(0,a.kt)("p",null,"Estos operadores nos permiten trabajar con arrays y objetos de una manera m\xe1s sencilla. Ambos hacen uso de la sintaxis de puntos ",(0,a.kt)("inlineCode",{parentName:"p"},"..."),", sin embargo tienen un significado diferente."),(0,a.kt)("h2",{id:"operador-rest"},"Operador Rest"),(0,a.kt)("p",null,"El operador rest nos permite representar un n\xfamero indefinido de argumentos como un array. Para usarlo debemos colocar los tres puntos ",(0,a.kt)("inlineCode",{parentName:"p"},"...")," antes del nombre del par\xe1metro que representar\xe1 el array de argumentos."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'function informacion(nombre, apellido, ...otraInfo) {\n  return otraInfo;\n}\n\nconst resultado = informacion("Juan", "P\xe9rez", 1.72, "Colombia", "Bogot\xe1");\n\nconsole.log(resultado); // [1.72, "Colombia", "Bogot\xe1"]\n')),(0,a.kt)("p",null,"El operador rest tambi\xe9n se puede usar para desestructurar arrays y objetos:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const frutas = ["Manzana", "Pl\xe1tano", "Cereza", "Fresa"];\n\nconst [primeraFruta, segundaFruta, ...restoFrutas] = frutas;\n\nconsole.log(primeraFruta); // Manzana\nconsole.log(segundaFruta); // Pl\xe1tano\nconsole.log(restoFrutas); // ["Cereza", "Fresa"]\n\nconst persona = {\n  nombre: "Juan",\n  apellido: "P\xe9rez",\n  altura: 1.72,\n  pais: "Colombia",\n  ciudad: "Bogot\xe1",\n};\n\nconst { nombre, apellido, ...restoInfo } = persona;\n\nconsole.log(nombre); // Juan\nconsole.log(apellido); // P\xe9rez\nconsole.log(restoInfo); // { altura: 1.72, pais: "Colombia", ciudad: "Bogot\xe1" }\n')),(0,a.kt)("admonition",{title:"Ojo con el orden",type:"note"},(0,a.kt)("p",{parentName:"admonition"},"El operador rest debe ir siempre al final de la desestructuraci\xf3n, ya que de lo contrario no funcionar\xe1 correctamente."),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const frutas = ["Manzana", "Pl\xe1tano", "Cereza", "Fresa"];\n\nconst [...restoFrutas, primeraFruta, segundaFruta] = frutas;\n// SyntaxError: Rest element must be last element\n'))),(0,a.kt)("h2",{id:"operador-spread"},"Operador Spread"),(0,a.kt)("p",null,"El operador spread nos permite descomponer o desempaquetar un array u objeto en elementos induviduales, con el objetivo de expandirlos en un nuevo array u objeto."),(0,a.kt)("p",null,"Usando el operador spread con arrays:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const frutas = ["Manzana", "Pl\xe1tano", "Cereza", "Fresa"];\nconst verduras = ["Lechuga", "Zanahoria", "Cebolla"];\n\nconst alimentos = [...frutas, ...verduras];\n\nconsole.log(alimentos);\n// ["Manzana", "Pl\xe1tano", "Cereza", "Fresa", "Lechuga", "Zanahoria", "Cebolla"]\n')),(0,a.kt)("p",null,"Tambi\xe9n podemos usar el operador spread con los objetos:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const direccion = {\n  pais: "Colombia",\n  ciudad: "Bogot\xe1",\n}\n\nconst persona = {\n  nombre: "Juan",\n  apellido: "P\xe9rez",\n  altura: 1.72,\n  ...direccion,\n}\n\nconsole.log(persona);\n// { nombre: "Juan", apellido: "P\xe9rez", altura: 1.72, pais: "Colombia", ciudad: "Bogot\xe1" }\n')),(0,a.kt)("admonition",{title:"Copia de objetos",type:"info"},(0,a.kt)("p",{parentName:"admonition"},"En el ejemplo anterior uno podr\xeda pensar que al momento de modificar el objeto ",(0,a.kt)("inlineCode",{parentName:"p"},"direccion")," tambi\xe9n se modificar\xeda el objeto ",(0,a.kt)("inlineCode",{parentName:"p"},"persona"),", pero esto no es as\xed, ya que el operador spread crea una copia del objeto ",(0,a.kt)("inlineCode",{parentName:"p"},"direccion")," y lo agrega al objeto ",(0,a.kt)("inlineCode",{parentName:"p"},"persona"),"."),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-js"},'direccion.ciudad = "Medell\xedn";\n\nconsole.log(persona);\n// { nombre: "Juan", apellido: "P\xe9rez", altura: 1.72, pais: "Colombia", ciudad: "Bogot\xe1" }\n\nconsole.log(direccion);\n// { pais: "Colombia", ciudad: "Medell\xedn" }\n')),(0,a.kt)("p",{parentName:"admonition"},"Aqu\xed vemos que ha pesar de haber modificado el objeto direcci\xf3n, el objeto persona no se ha visto afectado."),(0,a.kt)("p",{parentName:"admonition"},"Sin embargo, esto solo aplica cuando tenemos valores primitivos en el objeto o array, ya que si tenemos valores no primitivos como objetos o arrays, estos se copiaran por referencia, por lo que si modificamos el objeto o array original, tambi\xe9n se ver\xe1 afectado el objeto o array copiado."),(0,a.kt)("p",{parentName:"admonition"},"Con arrays:"),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const nombre = [["Juan", "P\xe9rez"]];\nconst info = ["Alumno", ...nombre, 1.72];\n\nconsole.log(info);\n// ["Alumno", ["Juan", "P\xe9rez"], 1.72]\n\nnombre[0].push("G\xf3mez");\n\nconsole.log(nombre);\n// [["Juan", "P\xe9rez", "G\xf3mez"]]\nconsole.log(info);\n// ["Alumno", ["Juan", "P\xe9rez", "G\xf3mez"], 1.72]\n\n')),(0,a.kt)("p",{parentName:"admonition"},"Con objetos:"),(0,a.kt)("pre",{parentName:"admonition"},(0,a.kt)("code",{parentName:"pre",className:"language-js"},'// usando objetos\nconst miNombre = {\n  nombreCompleto: {\n    nombre: "Juan",\n    apellido: "P\xe9rez",\n  },\n}\n\nconst miBio = {\n  profesion: "Desarrollador Web",\n  ...miNombre,\n};\n\nconsole.log(miBio);\n// { profesion: "Desarrollador Web", nombreCompleto: { nombre: "Juan", apellido: "P\xe9rez" } }\n\nmiNombre.nombreCompleto.nombre = "Pedro";\n\nconsole.log(miNombre);\n// { nombreCompleto: { nombre: "Pedro", apellido: "P\xe9rez" } }\n\nconsole.log(miBio);\n// { profesion: "Desarrollador Web", nombreCompleto: { nombre: "Pedro", apellido: "P\xe9rez" } }\n'))),(0,a.kt)("p",null,"Incluso podemos usar el operador spread con funciones:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'function obtenerInformacion(nombre, apellido, altura) {\n  return `${nombre} ${apellido} mide ${altura} metros`;\n}\n\nconst persona = {\n  nombre: "Juan",\n  apellido: "P\xe9rez",\n  altura: 1.72,\n};\n\nconst resultado = obtenerInformacion(...persona);\nconsole.log(resultado); // Juan P\xe9rez mide 1.72 metros\n')),(0,a.kt)("p",null,"Es importante saber la diferencia entre estos dos operadores, ya que ser\xe1n \xfatiles para nuestro d\xeda a d\xeda al utilizar javascript."))}c.isMDXComponent=!0}}]);